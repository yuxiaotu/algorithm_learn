# 归并排序

归并排序，也是「分治思想」下的排序方法。时间复杂度是 `O(nlogn)`。

- 将一个无序的序列分为两个无序的子序列。
- 然后将这两个无序的子序列再拆分，变成了四个无序的子序列。
- 依次类推，一直到子序列无法拆分。
- 然后比较大小进行合并，这样逐层往上，最后使得整个数组都有序。

## 01. Javascript
```js
function merge = function(leftNums, rightNums) {
  var result = [];
  while (leftNums.length > 0 && rightNums.length > 0) {
    if (leftNums[0] < rightNums[0]) {
      result.push(leftNums.shift());
    } else {
      result.push(rightNums.shift());
    }
  }
  return result.concat(leftNums).concat(rightNums);
}

function sort = function(nums) {
  if (nums.length < 2) return nums;
  let mid = Math.floot(nums.length / 2);
  let leftNums = nums.slice(0, mid);
  let rightNums = nums.slice(mid);
  return merge(sort(leftNums), sort(rightNums));
}
```

## 01. Java
```java
class Solution {
  public static void sort(int[] a, int low, int mid, int high) {
    let mid = (low+high) / 2;
    if (low < high) {
      sort(a, low, mid);
      sort(a, mid, high);
      merge(a, low, mid, high);
    }
    return a;
  }

  public static void merge(int[]a, int low, int mid, int high) {
    int[] temp = new int[high-mid+1];
    int i = low;
    int j = mid+1;
    int k = 0;
    while (i < mid && j < high) {
      if (a[i] < a[j]) {
        temp[k++] = a[i++];
      } else {
        temp[k++] = a[j++];
      }
    }

    while (i <= mid) {
      temp[k++] = a[i++];
    }

    while (j <= high) {
      temp[k++] = a[j++];
    }

    for (int x = 0; x < temp.length; x++) {
      a[x+low] = temp[x];
    }
  }
}
```
