# 二叉搜索树实现

## 01. 含义
首先 [二叉树搜索树](https://www.geeksforgeeks.org/binary-search-tree-data-structure/?ref=gcse) 满足二叉树的性质，同时对于任意结点，其左子树中的关键字不大于父结点的关键字，而其右子树的关键字不小于父结点的关键字。

## 02. 遍历搜索二叉树
可以通过一个递归的方法按序输出二叉搜索树的所有关键字。按照访问根结点的顺序可以分为以下三种：
- #### 先序遍历
  先访问根结点，再访问左右子树。
- #### 中序遍历
  先访问左子树，再访问根结点，最后访问右子树。
- #### 后序遍历
  先访问左子树，然后访问右子树，最后访问根结点。

```c
preorder_tree_walk(x) {
  if (x != null) {
    print x.key
    preorder_tree_walk(x, left)
    preorder_tree_walk(x, right)
  }
}
```

```c
inorder_tree_walk(x) {
  if (x != null) {
    inorder_tree_walk(x, left)
    print x.key
    inorder_tree_walk(x, right)
  }
}
```

```c
postorder_tree_walk(x) {
  if (x != null) {
    postorder_tree_walk(x, left)
    postorder_tree_walk(x, right)
    print x.key
  }
}
```

## 03. 查询二叉搜索树
输入一个指向树根的指针和一个关键字 k, 如果这个 k 存在则返回指向这个结点的指针。

```c
tree_search(x, k) {
  if (x == null || k == x.key) {
    return x
  } 

  if (k < x.key) {
    return tree_search(x, left, k)
  } else {
    return tree_search(x, right, k)
  }
}
```

采用 while 循环来展开递归。

```c
iterative_tree_search(x, k) {
  while (x != null && k != x.key) {
    if (k < x.key) {
      x = x.left
    } else {
      x = x.right
    }
  }
}
```

## 03. 查找最大值和最小值
从根开始沿着左子树直到遇到一个 null，总能找到一个元素是最小值。

```c
tree_minimum(x) {
  while (x.left != null) {
    x = x.left
  }
  return x;
}
```
同样沿着右子树直到遇到一个 null，总能找到一个元素是最大值。

```c
tree_maximum(x) {
  while (x.right != null) {
    x = x.right
  }
  return x
}
```

## 04. 后继和前驱
二叉搜索树可以通过没有任何关键字的比较来确定一个结点的后继。当所有结点互不相同时，一个结点 x 的后继是大于 x.key 的最小值的结点。

```c
tree_successor(x) {
  if (x.right != null) {
    return tree_minimum(x.right)
  }

  y = x.p
  while (y != null && x == y.right) {
    x = y
    y = y.p
  }
  return y
}
```

## 05. 插入和删除
将一个新值 v 插入到一颗二叉搜索树 T 中，以结点 z 作为输入，其中 z.key = v，z.left = null，z.right = null。

指针 x 记录了一条向下的简单路径，遍历指针 y 作为 x 的双亲，

while 循环使得这两个指针沿着树向下移动，向左或者是向右移动取决于 z.key 和 y.key 的比较。

当 x 变为 null，这个 null 就占据的位置就是 z 要放置的地方。

```c
tree_insert(T, z) {
  y = null
  x = T.root
  while (x != null) {
    y = x
    if (z.key < x.key) {
      x = x.left
    } else {
      x = x.right
    }
  }
  z.p = y
  if (y == null) {
    T.root = z
  } else if (z.key < y.key) {
    y.left = z
  } else {
    y.right = z
  }
}
```

