# 广度优先搜索

## 01. 含义
[广度优先搜索（BFS）](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2) 是连通图的一种遍历算法。可以系统地展开并检查图中的所有结点，以寻找结点。广度优先搜索是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。

![BFS](https://xoyolucas.github.io/2019/11/05/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/BFS.JPG)

## 02. 结点访问过程
- 在概念上将每个结点涂成「白色」，「灰色」，「黑色」。
- 开始时所有结点是「白色」，待访问的结点是「灰色」，访问过的结点是「黑色」。
- 一开始，该树仅有根结点，标记为 `s`。
- 在扫描已经发现的结点 `u` 的邻接链表时，每当发现一个白色的结点 `v` 就将结点 `v` 和边 `(u，v)` 加入到该树中。
- `u` 是 `v` 的前驱或者是父结点。每个结点最多被发现一次，它最多只有一个父结点。
- 如果 `u` 是从根结点 `s` 到结点 `v` 的简单路径上的一个结点，则结点 `u` 是 `v` 的祖先，`v` 是结点 `u` 的后代。

## 03. 伪代码实现
开始时需要将根结点外的所有结点设为「白色」，也就是未访问过的状态。然后将根结点设为「灰色」。

```c
for (u in G.V-{s}) {
  u.color = WHITE
  u.d = 0
  u.PI = NULL
}
s.color = GRAY
s.d = 0
s.PI = NULL
```

使用一个先进先出的队列 `Q` 来管理灰色结点。

```c
while (!Q.empty) {
  u = deQueue(Q)
  for (v in G.Adj[u]) {
    if (v.color == WHITE) {
        v.color = GRAY
        v.d = u.d + 1
        v.PI = u
        enQueue(Q, v)
    }
  }
  u.color = BLACK
}
```

## 04. JavaScript
```js
const bfs = function(node) {
  let Q = [];
  let nodes = [];
  if (node) {
    Q.push(node);
    while (Q.length) {
      let U = Q.shift();
      nodes.push(U);
      let V = U.V;
      for (let i = 0; i < V.length; i++) {
        Q.push(V[i]);
      }
    }
  }
  return nodes;
}
```