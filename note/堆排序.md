# 堆排序

## 01. 堆的含义
[堆排序](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F) 引入了「[堆](https://www.geeksforgeeks.org/heap-data-structure/)」 这种数据结构。

`二叉堆` 是一个数组，它可以被看成是一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。通过给定的下标，就可以计算得到它的父结点、左孩子和右孩子的下标。
```c
parent(i) {
  return [i/2]
}
```

```c
left(i) {
  return 2i+1
}
```

```c
right(i) {
  return 2i+2
}
```
二叉堆可以分为：`最大堆` 和 `最小堆`。
- 最大堆：A[parent(i)] >= A[i]
- 最小堆：A[parent(i)] <= A[i]

## 02. 建堆
以「最大堆」为例，要维护最大堆的性质，保证数组中 `A[parent(i)] >= A[i]` 成立。

当 `A[i]` 有可能小于其孩子，`max-heapify` 通过让 A[i] 在大堆中「逐级下降」，从而使得以下标 i 为根结点的子树遵循最大堆的性质。  

```c
max_heapify(A, i) {
  L = left(i)
  R = right(i)

  if (L <= A.heap-size && A[L] > A[R]) {
    largest = L
  } else {
    largest = R
  }

  if (R <= A.heap-size && A[R] > A[largest]) {
    largest = R
  }

  if (largest != i) {
    swap(A[i], A[largest])
    max_heapify(A, largest)
  }
}
```

从 `A.length/2` 开始遍历，`i+1`、`i+2`、... `n` 都是最大堆。

```c
build_max_heap(A) {
  A.heap-size = A.length
  for (i = A.length/2; i >= 1; i--) {
    max_heapify(A, i)
  }
}
```

## 03. 堆排序算法过程
- 将输入数组 A[0 .. n] 建成最大堆。
- 把最大元素 A[0] 和 A[n] 交换。
- 从堆中去掉结点 n，剩余的结点仍然是最大堆。
- 重复这一过程，直到堆的大小从 `n + 1` 降到 2。

## 04. Java
左孩子
```java
private static int leftChild(int i) {
  return 2 * i + 1;
}
```

右孩子
```java
private static int rightChild(int i) {
  return 2 * i + 2;
}
```

构建堆
```java
private static void maxHeapify(int[] A, i) {
  int L = leftChild(i);
  int R = rightChild(i);
  int len = A.length - 1;
  int largest;

  if (L < len && A[L] > A[R]) {
    largest = L;
  } else {
    largest = R;
  }

  if (R < len && A[R] > A[largest]) {
    largest = R;
  }

  if (largest != i) {
    swap(A[i], A[largest]);
    maxHeapify(A, largest);
  }
}
```

```java
private static void buildMaxHeap(int[] A) {
  int len = A.length - 1;
  for (int i = (len - 1) / 2; i >= 0; i--) {
    maxHeapify(A, i);
  }
}
```

排序
```java
public static void heapSort(int[] A) {
  A = buildMaxHeap(A);
  for (int i = A.length - 1; i >= 0; i--) {
    swap(A[0], A[i]);
    maxHeapify(A, i);
  }
}
```

## 05. JavaScript
```js
buildMaxHeap = function(nums[], i) {
  let len = nums.length;
  for (let j = 2 * i + 1; j < len; j = 2 * j + 1) {
    let temp = A[i];
    if (j + 1 < len && nums[j] + nums[j + 1]) {
      j++;
    } 
    if (temp < nums[j]) {
      swap(nums, i, j);
      i = j;
    } else {
      break;
    }
  }
}

sort = function(nums[]) {
  for (let i = Math.floor(nums.length / 2 - 1); i >= 0; i--) {
    buildMaxHeap(nums, i);
  }

  for (let i = Math.floor(nums.length - 1); i > 0; i--) {
    swap(nums, 0, i);
    buildMeap(nums, 0, i);
  }
}
```


## C++
```c++
class Solution {
  void maxHeap(int arr[], int start, int end) {
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end) {
      if (son + 1 <= end && arr[son] < arr[son+1]) {
        son++;
      } 

      if (arr[dad] > arr[son]) {
        return;
      } else {
        swap(arr[dad], arr[son]);
        dad = son;
        son = dad * 2 + 1;
      }
    }
  }

  void sort(int arr[], int len) {
    for (int i = len / 2 -1; i >= 0; i--) {
      maxHeap(arr, i, len-1);
    }

    for (int i = len - 1; i > 0; i--) {
      swap(arr[0], arr[i]);
      maxHeap(arr, 0, i - 1);
    }
  }
}
```