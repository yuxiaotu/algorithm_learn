# 二叉搜索树实现

## 01. 含义
[二叉树搜索树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9) 满足二叉树的性质，同时对于任意结点，其左子树中的关键字不大于父结点的关键字，而其右子树的关键字不小于父结点的关键字。


## 02. 遍历二叉搜索树
按照访问根结点的顺序可以将二叉树的遍历分为以下三种情况：
- #### 先序遍历
  先访问根结点，然后访问左子树，最后右子树。
- #### 中序遍历
  先访问左子树，然后访问根结点，最后访问右子树。
- #### 后序遍历
  先访问左子树，然后访问右子树，最后访问根结点。


## 03. 递归法的伪代码
```c
preorder_tree_walk(root) {
  if (root != null) {
    print root.val
    preorder_tree_walk(root.left)
    preorder_tree_walk(root.right)
  }
}
```

```c
inorder_tree_walk(root) {
  if (x != null) {
    inorder_tree_walk(root.left)
    print root.val
    inorder_tree_walk(root.right)
  }
}
```

```c
postorder_tree_walk(root) {
  if (root != null) {
    postorder_tree_walk(root.left)
    postorder_tree_walk(root.right)
    print root.val
  }
}
```


## 04. 迭代法的伪代码
```c
preorder_tree_walk(root) {
  stack stk
  stk.push(root)
  while (root != null || !stk.empty) {
    root = stk.pop()
    print root.val
    if (root.right != null) {
      stk.push(root.right)
    }
    if (root.left != null) {
      stk.push(root.left)
    }
  } 
}
```

```c
inorder_tree_walk(root) {
  stack stk
  while (root != null || !stk.empty) {
    while (root != null) {
      stk.push(root)
      root = root.left
    }
    root = stk.pop()
    print root.val
    root = root.right
  }
}
```

```c
postorder_tree_walk(x) {
  stack stk
  stk.push(root)
  while (root != null || !stk.empty) {
    while (root != null) {
      stk.push(root)
      root = root.left
    }
    root = stk.pop()
    root = root.right
    print root.val
  }
}
```



## 03. 查找关键字
输入一个指向树根的指针和一个关键字 `k`, 如果这个 `k` 存在则返回指向这个结点的指针。

当 `k` 小于根结点的值，就在左子树中查询；当 `k` 大于根结点的值，就在右子树中查询。

```c
tree_search(root, k) {
  if (x == null || k == x.key) {
    return x
  } 

  if (k < x.key) {
    return tree_search(x.left, k)
  } else {
    return tree_search(x.right, k)
  }
}
```

```c
iterative_tree_search(x, k) {
  while (x != null && k != x.key) {
    if (k < x.key) {
      x = x.left
    } else {
      x = x.right
    }
  }
}
```


## 03. 查找最大值或最小值
根据二叉搜索树的性质，从根开始沿着左子树直到遇到一个 `null`，总能找到一个结点是最小值。

同样沿着右子树直到遇到一个 `null`，总能找到一个元素是最大值。

```c
tree_minimum(x) {
  while (x.left != null) {
    x = x.left
  }
  return x;
}
```

```c
tree_maximum(x) {
  while (x.right != null) {
    x = x.right
  }
  return x
}
```

## 04. 查找后继或前驱
二叉搜索树可以通过没有任何关键字的比较来确定一个结点的后继。当所有结点互不相同时，一个结点 `x` 的后继是大于 `x.key` 的最小值的结点。

```c
tree_successor(x) {
  if (x.right != null) {
    return tree_minimum(x.right)
  }

  y = x.p
  while (y != null && x == y.right) {
    x = y
    y = y.p
  }
  return y
}
```


## 05. 插入和删除
将一个新值 `v` 插入到一颗二叉搜索树 `T` 中，以结点 `z` 作为输入结点，其中 `z.key = v`，`z.left = null`，`z.right = null`。

指针 `x` 记录了一条向下的简单路径，遍历指针 `y` 作为 `x` 的双亲，

`while` 循环使得这两个指针沿着树向下移动，向左或者是向右移动取决于 `z.key` 和 `y.key` 的比较。

当 `x` 变为 `null`，这个 `null`k 就占据的位置就是 z 要放置的地方。

```c
tree_insert(T, z) {
  y = null
  x = T.root
  while (x != null) {
    y = x
    if (z.key < x.key) {
      x = x.left
    } else {
      x = x.right
    }
  }
  z.p = y
  if (y == null) {
    T.root = z
  } else if (z.key < y.key) {
    y.left = z
  } else {
    y.right = z
  }
}
```

